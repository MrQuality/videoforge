//! Test utilities shared across integration tests.

use std::{fs, io, path::PathBuf};

use tempfile::TempDir;

/// Raw bytes for a 1x1 transparent PNG (color type RGBA) used when exercising the
/// decode stage. The payload was generated with ImageMagick and verified via
/// `pngcheck` to ensure FFmpeg can inflate it successfully during tests.
const SAMPLE_PNG: &[u8] = &[
    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x08, 0x06, 0x00, 0x00, 0x00, 0x1f, 0x15, 0xc4,
    0x89, 0x00, 0x00, 0x00, 0x0a, 0x49, 0x44, 0x41, 0x54, 0x78, 0x9c, 0x63, 0x60, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x01, 0xe2, 0x21, 0xbc, 0x33, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae,
    0x42, 0x60, 0x82,
];

/// Materializes the sample PNG in a temporary directory and returns its location.
///
/// Keeping the [`TempDir`] alive ensures the file remains available for the
/// duration of each test.
pub fn write_sample_png() -> io::Result<(TempDir, PathBuf)> {
    let dir = TempDir::new()?;
    let path = dir.path().join("frame.png");
    // Persist the deterministic sample image to disk for FFmpeg to consume.
    fs::write(&path, SAMPLE_PNG)?;
    Ok((dir, path))
}
